/*
 * ADCReader.cpp
 *
 *  Created on: 01.11.2022
 *      Author: User
 */

#include "ADCReader.h"
#include <iostream>

ADCReader::ADCReader() {
	// TODO Auto-generated constructor stub

}

ADCReader::~ADCReader() {
	// TODO Auto-generated destructor stub
}

int ADCReader::runADCReader(){

	// Client to connect too
	Hoehenauswertung client(1,0);

	//TODO Hier so wird ein thread mit Methode und Objekt aufgerufen
	std::thread t = std::thread(&Hoehenauswertung::evaluateSomething, &client);

	printf("STARTING ADC!\n");
	uintptr_t adc_bank = mmap_device_io(ADC_ADDRESS_LENGTH, ADC_START_ADDRESS);
	out32(ADC_IRQ_ENABLE_SET(adc_bank), 0x2); // enable ADC irq
	out32(ADC_CTRL(adc_bank), 0x1); // start sampling for one data

	struct sigevent adc_event;

	// Create a channel for ISR Pulse messages
	int chid = ChannelCreate( 0 );
	if (chid == -1) {
		fprintf(stderr, "Error creating a channel %d\n", errno);
		exit(1);
	}

	// Create a connection to pass over to the event
	int coid = ConnectAttach( 0, 0, chid, _NTO_SIDE_CHANNEL, 0 );
	if (coid == -1) {
		fprintf(stderr, "Error attaching to channel %d\n", errno);
		exit(1);
	}

	// create a connection to the receiving end of events
	int clientCoid = ConnectAttach(0, 0, client.getChannelID(), _NTO_SIDE_CHANNEL, 0);
	if (clientCoid == -1) {
		fprintf(stderr, "Error attaching to dispatcher %d\n", errno);
		exit(1);
	}

	// creates an pulse message which is sent when the event occurs
	SIGEV_PULSE_INIT( &adc_event, coid, SIGEV_PULSE_PRIO_INHERIT, EVT_ADC_VALUE, 0 );

	// configure our thread
	ThreadCtl( _NTO_TCTL_IO, 0 );

	// attach our created event to an interrupt
	int intIdGPIO = InterruptAttachEvent(ADC_IRQ_NUMBER, &adc_event, 0);
	if (intIdGPIO == -1) {
		fprintf(stderr, "Error attaching interrupt for GPIO %d\n", errno);
		exit(1);
	}

	struct _pulse pulse;

	printf("INIT ADC DETECTION!\n");
	while (true) {

		// wait for an pulse message event generated by the kernel
		if (MsgReceivePulse(chid, &pulse, sizeof(pulse), NULL) == -1) {
			printf("MsgReceivePulse failed %d \n", errno);
			exit(1);
		}

		if (pulse.code == EVT_ADC_VALUE) {
			// reset adc irq
			out32(ADC_IRQ_STATUS(adc_bank), 0x2);

			// unmask the interrupt, so we can get the next
			InterruptUnmask(ADC_IRQ_NUMBER, intIdGPIO);

			// read adc data
			uint32_t data = in32(ADC_DATA(adc_bank));

			// start sampling
			out32(ADC_CTRL(adc_bank), 0x1);

			// publish adc data
			int res = MsgSendPulse(clientCoid, -1, EVT_ADC_VALUE, data);
			if (res < 0) {
				printf("Failed to send! %d\n", errno);
			}

			continue;
		}
			// if pulse code is not handled above, it is unexpected
			fprintf(stderr, "Unexpected Pulse code %d\n", pulse.code);
			exit(1);
	}

	return 0;
}

