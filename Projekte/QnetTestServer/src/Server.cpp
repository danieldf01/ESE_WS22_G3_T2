#include <stdio.h>
#include <errno.h>
#include <stdlib.h>
#include <string.h>
#include <sys/dispatch.h>
#include <gtest/gtest.h>
#include <iostream>

#define ATTACH_POINT "server"

using namespace std;

class server {

public:

//global variables
	name_attach_t *attach;
	int rcvid;
	int chid = 0;

	int serverAttach() {
// Create a unique global name known within the network
		if ((attach = name_attach(NULL, ATTACH_POINT, NAME_FLAG_ATTACH_GLOBAL))
				== NULL) {
			perror("Server: name_attach failed");
			return EXIT_FAILURE;
		}
		cout << "Server: channel successfully opened with name " << ATTACH_POINT
				<< "\n";
		chid = attach->chid;
		return chid;
	}

	int rcvMsgAndDetach() {
		_pulse pulse;
		rcvid = MsgReceive(attach->chid, &pulse, sizeof(_pulse), NULL);

		if (rcvid == -1) { // Error occurred
			perror("Server: MsgReceived failed");
		}
		if (rcvid == 0) { // Pulse was received
			handle_pulse(pulse, rcvid);
		}
		// some sync msg was received
		if ((_IO_BASE <= pulse.type) && (pulse.type <= _IO_MAX)) {
			// Some QNX IO msg generated by gns was received
			handle_ONX_IO_msg(pulse, rcvid);
		}
		// A sync msg (presumable ours) was received; handle it
		cout << "Server: received unexpected sync message" << endl;
		name_detach(attach, 0);
		return EXIT_SUCCESS;
	}

	void handle_pulse(_pulse pulse, int rcvid) {
		switch (pulse.code) {
		case _PULSE_CODE_DISCONNECT:
			printf("Server received _PULSE_CODE_DISCONNECT\n");
			/* A client disconnected all its connections (called
			 * name_close() for each name_open() of our name) or
			 * terminated. */
			ConnectDetach(pulse.scoid);
			break;
		case _PULSE_CODE_UNBLOCK:
			printf("Server received _PULSE_CODE_UNBLOCK\n");
			/* REPLY blocked client wants to unblock (was hit by
			 * a signal or timed out). It's up to you if you
			 * reply now or later. */
			break;
		default:
			/* A pulse sent by one of your processes or a
			 * _PULSE_CODE_COIDDEATH or _PULSE_CODE_THREADDEATH
			 * from the kernel? */
			printf("Server: received some pulse msg: %d\n", pulse.value);
			break;
		}
	}

	void handle_ONX_IO_msg(_pulse pulse, int rcvid) {
		if (pulse.type == _IO_CONNECT) {
// QNX IO msg _IO_CONNECT was received; answer with EOK
			printf("Server received _IO_CONNECT (sync. msg) \n");
			MsgReply(rcvid, EOK, NULL, 0);
			return;
		}
// Some other QNX IO message was received; reject it
		printf("Server received unexpected (sync.) msg type = 0x%04X\n",
				pulse.type);
		MsgError(rcvid, ENOSYS);
	}
};
